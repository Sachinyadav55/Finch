require(Matrix)

#' kmerdistance package
#' R package use for calculating pairwise distance between genome base on kmer stratege
NULL

#' kmerDistance.dif
#' Usage
#' kmerDistance.dif <- function(kmer.length,path.to.data="../data/",output="kemr.dif.distance.csv")
#' Description
#' calculate pairwise distnace of kmer data by using XOR discrete funtion. 
#' Arguments
#' kmer.length		length of kmer.
#' path.to.data		path to test data. Test data is integer kc files generated by using Kanalyze.
#' output			output file, the default output file formate is csv.

kmerDistance.dif <- function(kmer.length,path.to.data="../data/",output="kmer.dif.distance.csv"){
	if (is.null(kmer.length))
		stop("Please specify the length of kmer");
	if (is.null(path.to.data))
		stop("Please specify the path to test data");
	
	#read in all kc files in path.to.data
	kcFiles=list.files(path.to.data,"*.kc");
	l=length(kcFiles);
	#save all kmers in klist
	klist<-new.env()
	for (i in 1:l){
		temp=read.table(paste(path.to.data,kcFiles[i],sep=""));
		klist[[kcFiles[i]]]=temp[,1];
	}
	#create a matrix to hold the diferential occupancy distance
	dif.occupancy=matrix(0,l,l);
	#calculate the pairwise distance
	for(i in 1:l){
		j=i+1
		while(j <=l){
			l1=length(klist[[kcFiles[i]]]);
			l2=length(klist[[kcFiles[j]]]);
			dt=length(intersect(klist[[kcFiles[i]]],klist[[kcFiles[j]]]));
			dif.occupancy[i,j]=dif.occupancy[j,i]=(l1+l2-2*dt)/(4^kmer.length);		
			j=j+1;
		}
	}
	#output result
	difd=data.frame(dif.occupancy);
	names(difd)=kcFiles;
	write.csv(difd,output,row.names=kcFiles);
	return(difd);
}


#' kmerDistance.hpca
#' Usage
#' kmerDistance.pca <- function(filename,outputfile, plotmain = "Main", ifscale = 1, ifbinary = 0, numofp = 3)
#' Description
#' calculate pairwise distnace of kmer data by using hierarchical PCA.
#' Arguments
#' kmer.length		length of kmer.
#' path.to.data		path to test data. Test data is integer kc files generated by using Kanalyze.
#' output			output file, the default output file formate is csv.
#' ifscale			scale flag. if this flag set to true, the data is scaled.
#' ifbinary			binary flag. if this flag set true, the kmer counts are set to binary number.
#' numofp			number of components used to calculate the distance


kmerDistance.hpca <- function(kmer.length, path.to.data="../data/", outputfile="kmer.hpca.distance.csv", ifscale = TRUE, ifbinary = FALSE, numofp = 3, plot = FALSE, plotmain = "Main"){
	if (is.null(kmer.length))
		stop("Please specify the length of kmer");
	if (is.null(path.to.data))
		stop("Please specify the input file");
	if (is.null(outputfile))
		stop("Please specify the output file");
	
	#read in all kc files in path.to.data
	kcFiles=list.files(path.to.data,"*.kc");
	l=length(kcFiles);
	
	for (i in 1:l){
		temp=read.table(paste(path.to.data,kcFiles[i],sep=""));
		tl=dim(temp)[1];
		if(i==1){
			klist=as.vector(sparseMatrix(c((temp[,1]+1),4^ kmer.length), as.vector(rep(1,tl+1)), x=c(temp[,2],0)));
		} else {
			klist=cbind(klist,as.vector(sparseMatrix(c((temp[,1]+1),4^ kmer.length), as.vector(rep(1,tl+1)), x=c(temp[,2],0))));
		}	
	}
	
	#scaled = scale(klist)
	if(ifscale)
		klist=scale(klist);
	if(!ifbinary){
		pcaloadings=princomp(klist)$loadings[,1:numofp];
	} else {
		scaled_binaried = ifelse(klist>0, 1, 0);
		pcaloadings=princomp(scaled_binaried)$loadings[,1:numofp];
	}


	#print 3d structre only when first 3 main components are used
	if(plot){
		require(rgl,quietly=T);
		thisplot = plot3d(pcaloadings,type="p",col="red",main=plotmain)+text3d(pcaloadings,text=rownames(pcaloadings),font=3,col="blue");
	}
	thisdist = as.matrix(dist(pcaloadings));
	hpcad=data.frame(thisdist,row.names = NULL,check.rows = FALSE);
	names(hpcad)=kcFiles;
	write.csv(hpcad,outputfile,row.names=kcFiles,quote=F);

	return(thisdist);
}

